package com.interview.notes.code.year.y2025.June.amazon.test4;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class KeyVulnerabilityMinimization {

    public static int findVulnerabilityFactor(List<Integer> key, int maxChange) {
        int n = key.size();
        int left = 1, right = n, answer = n;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (canAchieve(key, maxChange, mid)) {
                answer = mid;
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return answer;
    }

    // Can we make all GCD>1 subarrays of length >= L disappear with at most maxChange?
    private static boolean canAchieve(List<Integer> key, int maxChange, int L) {
        int n = key.size();
        int[] arr = key.stream().mapToInt(Integer::intValue).toArray();
        int changes = 0;
        boolean[] marked = new boolean[n];

        int i = 0;
        while (i <= n - L) {
            // Compute GCD of window [i, i+L-1]
            int windowGCD = arr[i];
            for (int j = i + 1; j < i + L; j++) {
                windowGCD = gcd(windowGCD, arr[j]);
                if (windowGCD == 1) break;
            }
            if (windowGCD == 1) {
                i++;
            } else {
                // We must break this window. Greedily, change the last element of the window.
                changes++;
                if (changes > maxChange) return false;
                arr[i + L - 1] = 1; // Simulate change for future windows
                i += L; // This window and all overlapping left windows are broken
            }
        }
        return true;
    }

    // GCD utility
    private static int gcd(int a, int b) {
        while (b != 0) {
            int t = b;
            b = a % b;
            a = t;
        }
        return a;
    }

    // Main method for provided & large test cases
    public static void main(String[] args) {
        // Provided examples
        test(Arrays.asList(2, 4, 9, 6), 1, 2);      // Example 1
        test(Arrays.asList(5, 10, 20, 10, 15, 5), 2, 2); // Example 2
        test(Arrays.asList(4, 2, 4), 1, 1);          // Example 3

        // Edge: All ones, should be 1
        test(Arrays.asList(1, 1, 1, 1, 1), 0, 1);

        // Edge: No change allowed, long run of GCD>1
        test(Arrays.asList(2, 4, 8, 16, 2, 1), 0, 4);

        // Large case: alternating 2 and 1, large maxChange
        List<Integer> largeList = new ArrayList<>();
        for (int i = 0; i < 100_000; i++) largeList.add(i % 2 == 0 ? 2 : 1);
        test(largeList, 100_000, 1);

        // Large case: all 2s, need to break up
        largeList = IntStream.range(0, 100_000).map(i -> 2).boxed().collect(Collectors.toList());
        test(largeList, 0, 100_000); // No changes allowed
        test(largeList, 10, 9091);   // With a few changes
    }

    private static void test(List<Integer> key, int maxChange, int expected) {
        long start = System.currentTimeMillis();
        int result = findVulnerabilityFactor(key, maxChange);
        boolean pass = (result == expected);
        System.out.println(
                "Input: " + (key.size() <= 10 ? key.toString() : "large[n=" + key.size() + "]")
                        + ", maxChange=" + maxChange + " | Expected: " + expected + " | Result: " + result + " | " + (pass ? "PASS" : "FAIL")
                        + " | Time: " + (System.currentTimeMillis() - start) + " ms");
    }
}
