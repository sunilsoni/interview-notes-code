package com.interview.notes.code.year.y2025.march.common.test7;

import java.util.*;

/*
WORKING 14/15


## **Question 3**
A **subsequence** of a given string is generated by deleting zero or more characters from a string and then concatenating the remaining characters.
A **good subsequence** is one where the frequency of each character is the same.

Given a string consisting of **n Latin letters**, determine how many **good subsequences** it contains.
Since the answer can be quite large, compute its modulo **(10⁹ + 7)**.

### **Note:**
- An **empty subsequence** is **not** a good subsequence.

---

## **Example**
```
word = "abca"
```
A total of **15** non-empty subsequences can be formed:
```
"a", "a", "aa", "ab", "aba", "abc", "abca", "ac", "aca", "b", "ba", "bc", "bca", "c", "ca"
```
The only **subsequences that are not good** are:
```
"aba", "aca", and "abca"
```
- The frequency of **'a'** is **2**, while every other character appears only once.
- So, the **total number of good subsequences** = **15 - 3 = 12**.
- The answer is:
```
12 modulo (10⁹ + 7) = 12
```

---

## **Function Description**
Complete the function **countGoodSubsequences** in the editor below.

### **Function Signature**
```java
public static int countGoodSubsequences(String word)
```

### **Parameters**
- **string word**: A string consisting of only lowercase Latin letters.

### **Returns**
- **int**: The number of **good subsequences**, modulo **(10⁹ + 7)**.

---

## **Constraints**
- **1 ≤ length of word ≤ 10⁵**
- **word[i]** is in the range **[a-z]**.

---

## **Input Format**
The first and only line consists of a string, **word**.

---

## **Sample Cases**
### **Sample Case 0**
#### **Input**
```
abcd
```
#### **Output**
```
15
```
#### **Explanation**
All of the non-empty subsequences are **good subsequences**:
```
"a", "ab", "abc", "abcd", "abd", "ac", "acd", "ad", "b", "bc", "bcd", "bd", "c", "cd", "d"
```
---

### **Sample Case 1**
#### **Input**
```
baab
```
#### **Output**
```
11
```
#### **Explanation**
The **subsequences that are NOT good**:
```
"baa", "aab", "bab", "bab"
```
The **good subsequences**:
```
"a", "a", "aa", "ab", "ab", "b", "b", "ba", "ba", "baab", "bb"
```

---


 */
public class GoodSubsequencesCounter {
    
    private static final int MOD = 1_000_000_007;
    
    public static int countGoodSubsequences(String word) {
        // Count frequency of each character
        int[] charFreq = new int[26];
        for(char c : word.toCharArray()){
            charFreq[c-'a']++;
        }
        
        // Find the maximum frequency
        int maxFreq = 0;
        for(int f : charFreq){
            maxFreq = Math.max(maxFreq, f);
        }
        
        long result = 0;
        
        // For each possible frequency
        for(int freq = 1; freq <= maxFreq; freq++){
            long subseqCount = 1;
            
            // For each character
            for(int i = 0; i < 26; i++){
                if(charFreq[i] >= freq){
                    // Calculate combination C(charFreq[i], freq)
                    long ways = nCrModPrime(charFreq[i], freq, MOD);
                    
                    // Multiply by (ways+1) - the +1 is for not choosing this character
                    subseqCount = (subseqCount * (ways + 1)) % MOD; 
                }
            }
            
            // Subtract 1 for the empty subsequence
            subseqCount = (subseqCount - 1 + MOD) % MOD;
            result = (result + subseqCount) % MOD;
        }
        return (int)result;
    }
    
    /**
     * Calculates nCr % p where p is prime.
     * Uses Fermat's Little Theorem for modular inverse.
     * 
     * @param n Number of elements
     * @param r Number to choose
     * @param p Prime modulus
     * @return nCr % p
     */
    private static long nCrModPrime(int n, int r, int p) {
        // Base cases
        if (r == 0) return 1;
        if (r > n) return 0;
        if (r > n - r) r = n - r; // Optimization: C(n,r) = C(n,n-r)
        
        // Calculate [n * (n-1) * ... * (n-r+1)] / [r * (r-1) * ... * 1]
        long num = 1, den = 1;
        for (int i = 0; i < r; i++) {
            num = (num * (n - i)) % p;
            den = (den * (i + 1)) % p;
        }
        
        // Calculate num * den^(p-2) % p using Fermat's Little Theorem
        return (num * modPow(den, p - 2, p)) % p;
    }

    /**
     * Calculates (base^exponent) % modulus efficiently.
     *
     * @param base The base
     * @param exponent The exponent
     * @param modulus The modulus
     * @return (base^exponent) % modulus
     */
    private static long modPow(long base, int exponent, int modulus) {
        long result = 1;
        base = base % modulus;

        while (exponent > 0) {
            if (exponent % 2 == 1) {
                result = (result * base) % modulus;
            }
            exponent >>= 1;
            base = (base * base) % modulus;
        }

        return result;
    }

    /**
     * Main method to test the solution with provided examples and additional test cases.
     */
    public static void main(String[] args) {
        // Test cases from the problem statement
        testCase("abcd", 15, "Sample Case 0");
        testCase("baab", 11, "Sample Case 1");
        testCase("abca", 12, "Example Case");

        // Additional test cases
        testCase("a", 1, "Single Character");
        testCase("aa", 3, "Two Same Characters");
        testCase("ab", 3, "Two Different Characters");
        testCase("aaa", 7, "Three Same Characters");
        testCase("aaaa", 15, "Four Same Characters");

        // Large input test case
        StringBuilder largeInput = new StringBuilder();
        Random rand = new Random(42); // Fixed seed for reproducibility
        for (int i = 0; i < 100000; i++) {
            largeInput.append((char)('a' + rand.nextInt(26)));
        }
        long startTime = System.currentTimeMillis();
        int result = countGoodSubsequences(largeInput.toString());
        long endTime = System.currentTimeMillis();
        System.out.println("Large Input (100,000 chars) - Result: " + result +
                ", Time: " + (endTime - startTime) + "ms");
    }

    /**
     * Helper method to run a test case and check if it passes or fails.
     *
     * @param input The input string
     * @param expected The expected output
     * @param testName The name of the test case
     */
    private static void testCase(String input, int expected, String testName) {
        int result = countGoodSubsequences(input);
        boolean passed = result == expected;
        System.out.println(testName + ": " + (passed ? "PASS" : "FAIL") +
                " (Expected: " + expected + ", Got: " + result + ")");
    }
}