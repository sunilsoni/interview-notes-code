package com.interview.notes.code.year.y2025.June.amazon.test2;

import java.util.*;
import java.util.stream.*;
/*
## **Code Question 2: Key Vulnerability Minimization**

The developers at Amazon IAM are working on identifying vulnerabilities in their **key generation process**. The key is represented by an array of integers, where the `i-th` integer is denoted by `key[i]`.

The **vulnerability factor** of the array is defined as the **maximum length of any subarray that has a GCD (Greatest Common Divisor) greater than 1**.

---

### **Problem Statement**

You are allowed to make **at most `maxChange` modifications** to the array, where each modification changes **any one element** to **any other positive integer**.

Your goal is to **minimize** the vulnerability factor after making up to `maxChange` changes.

* The length of an **empty subarray** is considered 0.
* GCD is always computed over contiguous subarrays.

---

### **Function Signature**

```java
public static int findVulnerabilityFactor(List<Integer> key, int maxChange)
```

### **Parameters**

* `key`: a `List<Integer>` representing the key array
* `maxChange`: an `int` representing the maximum number of elements that can be changed

### **Return**

* `int`: The **least possible vulnerability factor** of the key after performing up to `maxChange` modifications

---

## **Constraints**

* $1 \leq n \leq 10^5$
* $0 \leq \text{maxChange} \leq n$
* $1 \leq \text{key}[i] \leq 10^9$

---

### **Example 1**

#### **Input**

```plaintext
key = [2, 4, 9, 6]
maxChange = 1
```

#### **Output**

```plaintext
2
```

#### **Explanation**

* Change first element to 3 → `[3, 4, 9, 6]`, max GCD>1 subarray: `[2, 4]`, `[9, 6]`, longest = 2
* Change third element to 5 → `[2, 4, 5, 6]`, max GCD>1 subarray: `[2, 4]`, `[6]`, longest = 2

No change can reduce the vulnerability factor below 2.

---

### **Example 2**

#### **Input**

```plaintext
key = [5, 10, 20, 10, 15, 5]
maxChange = 2
```

#### **Output**

```plaintext
2
```

#### **Explanation**

* Change element 3 to 2 and element 4 to 3 → key = \[5, 10, 2, 3, 15, 5]
* Subarrays with GCD > 1: \[5], \[10], \[15], \[5] → longest = 2

---

### **Example 3**

#### **Input**

```plaintext
key = [4, 2, 4]
maxChange = 1
```

#### **Output**

```plaintext
1
```

#### **Explanation**

* Change `2` to `3` → key = `[4, 3, 4]`
* All GCD > 1 subarrays now have length = 1 → minimum vulnerability factor is 1

---

 */
public class KeyVulnerability {

    // main API
    public static int findVulnerabilityFactor(List<Integer> key, int maxChange) {
        int n = key.size();
        if (n == 0) return 0;

        // build gcd sparse table
        int LOG = 32 - Integer.numberOfLeadingZeros(n);
        int[][] st = new int[LOG][n];
        for (int i = 0; i < n; i++) st[0][i] = key.get(i);
        for (int k = 1; k < LOG; k++) {
            int len = 1 << (k - 1);
            for (int i = 0; i + (1<<k) <= n; i++) {
                st[k][i] = gcd(st[k-1][i], st[k-1][i + len]);
            }
        }
        // helper to query gcd(i…j)
        class Q {
            int query(int i, int j) {
                int lg = 31 - Integer.numberOfLeadingZeros(j - i + 1);
                return gcd(st[lg][i], st[lg][j - (1<<lg) + 1]);
            }
        }
        Q q = new Q();

        // binary search answer in [0…n]
        int lo = 0, hi = n, ans = n;
        while (lo <= hi) {
            int mid = (lo + hi) >>> 1;
            // collect all “bad” windows of length mid+1
            List<int[]> intervals = IntStream.range(0, n - mid)
                .filter(i -> q.query(i, i + mid) > 1)
                .mapToObj(i -> new int[]{i, i + mid})
                .collect(Collectors.toList());

            // greedy cover
            int used = 0, last = -1;
            for (int[] iv : intervals) {
                if (iv[0] <= last) continue;
                used++;
                last = iv[1];
                if (used > maxChange) break;
            }

            if (used <= maxChange) {
                ans = mid;
                hi = mid - 1;
            } else {
                lo = mid + 1;
            }
        }

        return ans;
    }

    private static int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }

    // simple main for tests (no JUnit)
    public static void main(String[] args) {
        class TC { List<Integer> k; int m, exp; TC(List<Integer> k,int m,int e){
            this.k=k; this.m=m; this.exp=e;
        }}
        List<TC> cases = Arrays.asList(
            new TC(Arrays.asList(2, 4, 9, 6),       1, 2),
            new TC(Arrays.asList(5,10,20,10,15, 5), 2, 2),
            new TC(Arrays.asList(4, 2, 4),          1, 1),
            // large case: all 2's, n=100_000, maxChange=50_000 ⇒ expect 1
            new TC(Collections.nCopies(100_000, 2), 50_000, 1)
        );

        int pass = 0;
        for (int i = 0; i < cases.size(); i++) {
            TC tc = cases.get(i);
            int got = findVulnerabilityFactor(tc.k, tc.m);
            boolean ok = got == tc.exp;
            System.out.printf(
              "Case %d: expected=%d, got=%d → %s%n",
              i+1, tc.exp, got, ok? "PASS":"FAIL"
            );
            if (ok) pass++;
        }
        System.out.printf("Passed %d/%d tests%n", pass, cases.size());
    }
}