package com.interview.notes.code.year.y2025.June.amazon.test1;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Random;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class KeyVulnerabilityMinimization {

    // Main function to be called
    public static int findVulnerabilityFactor(List<Integer> key, int maxChange) {
        int n = key.size();

        // Generate small primes up to 100 (arbitrary, practical value)
        List<Integer> smallPrimes = sievePrimes(100);

        // Binary search on answer
        int left = 1, right = n, answer = n;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (canAchieve(key, maxChange, mid, smallPrimes)) {
                answer = mid;
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return answer;
    }

    // Check if we can achieve vulnerability factor <= L
    private static boolean canAchieve(List<Integer> key, int maxChange, int L, List<Integer> primes) {
        int n = key.size();
        // For each small prime, try to "break" all windows of length L+1
        for (int prime : primes) {
            int[] isDiv = new int[n];
            for (int i = 0; i < n; ++i)
                isDiv[i] = (key.get(i) % prime == 0) ? 1 : 0;

            int currSum = IntStream.range(0, Math.min(L + 1, n)).map(i -> isDiv[i]).sum();
            int minChanges = currSum;
            for (int i = L + 1; i < n; ++i) {
                currSum += isDiv[i] - isDiv[i - (L + 1)];
                minChanges = Math.min(minChanges, currSum);
            }
            // If for this prime, there exists a window with <= maxChange elements divisible by prime,
            // that means we can break all such windows with maxChange changes
            if (minChanges <= maxChange)
                return true;
        }
        // As a fallback, try random numbers as pseudo-primes (handle large GCD cases)
        Random rand = new Random(42);
        for (int iter = 0; iter < 20; ++iter) {
            int idx = rand.nextInt(key.size());
            int x = key.get(idx);
            if (x == 1) continue;
            for (int d = 2; d * d <= x; ++d) {
                if (x % d == 0) {
                    int p = d;
                    int[] isDiv = new int[n];
                    for (int i = 0; i < n; ++i)
                        isDiv[i] = (key.get(i) % p == 0) ? 1 : 0;
                    int currSum = IntStream.range(0, Math.min(L + 1, n)).map(i -> isDiv[i]).sum();
                    int minChanges = currSum;
                    for (int i = L + 1; i < n; ++i) {
                        currSum += isDiv[i] - isDiv[i - (L + 1)];
                        minChanges = Math.min(minChanges, currSum);
                    }
                    if (minChanges <= maxChange)
                        return true;
                    while (x % d == 0) x /= d;
                }
            }
            if (x > 1) {
                int p = x;
                int[] isDiv = new int[n];
                for (int i = 0; i < n; ++i)
                    isDiv[i] = (key.get(i) % p == 0) ? 1 : 0;
                int currSum = IntStream.range(0, Math.min(L + 1, n)).map(i -> isDiv[i]).sum();
                int minChanges = currSum;
                for (int i = L + 1; i < n; ++i) {
                    currSum += isDiv[i] - isDiv[i - (L + 1)];
                    minChanges = Math.min(minChanges, currSum);
                }
                if (minChanges <= maxChange)
                    return true;
            }
        }
        return false;
    }

    // Sieve of Eratosthenes for small primes
    private static List<Integer> sievePrimes(int max) {
        boolean[] isPrime = new boolean[max + 1];
        Arrays.fill(isPrime, true);
        isPrime[0] = isPrime[1] = false;
        for (int i = 2; i * i <= max; ++i) {
            if (isPrime[i]) {
                for (int j = i * i; j <= max; j += i) {
                    isPrime[j] = false;
                }
            }
        }
        List<Integer> primes = new ArrayList<>();
        for (int i = 2; i <= max; ++i) if (isPrime[i]) primes.add(i);
        return primes;
    }

    // MAIN METHOD FOR TESTING
    public static void main(String[] args) {
        // Test case 1
        List<Integer> key1 = Arrays.asList(2, 4, 9, 6);
        int maxChange1 = 1;
        int expected1 = 2;
        test(key1, maxChange1, expected1, 1);

        // Test case 2
        List<Integer> key2 = Arrays.asList(5, 10, 20, 10, 15, 5);
        int maxChange2 = 2;
        int expected2 = 2;
        test(key2, maxChange2, expected2, 2);

        // Test case 3
        List<Integer> key3 = Arrays.asList(4, 2, 4);
        int maxChange3 = 1;
        int expected3 = 1;
        test(key3, maxChange3, expected3, 3);

        // Edge case: All ones, no changes needed
        List<Integer> key4 = IntStream.range(0, 100000).mapToObj(i -> 1).collect(Collectors.toList());
        int maxChange4 = 0;
        int expected4 = 1;
        test(key4, maxChange4, expected4, 4);

        // Edge case: All large numbers, no changes allowed
        List<Integer> key5 = IntStream.range(0, 100000).mapToObj(i -> 1_000_000_007).collect(Collectors.toList());
        int maxChange5 = 0;
        int expected5 = 100000;
        test(key5, maxChange5, expected5, 5);

        // Edge case: Random mix, sufficient changes
        List<Integer> key6 = Arrays.asList(2, 3, 5, 7, 11, 13, 17, 19, 23, 29);
        int maxChange6 = 9;
        int expected6 = 1;
        test(key6, maxChange6, expected6, 6);

        // Large test case performance (no output, just for speed)
        List<Integer> key7 = IntStream.range(0, 100000).mapToObj(i -> (i % 6 == 0 ? 6 : 7)).collect(Collectors.toList());
        int maxChange7 = 1000;
        System.out.println("Large input test result: " + findVulnerabilityFactor(key7, maxChange7));
    }

    private static void test(List<Integer> key, int maxChange, int expected, int caseNum) {
        int result = findVulnerabilityFactor(key, maxChange);
        if (result == expected)
            System.out.println("Test " + caseNum + ": PASS");
        else
            System.out.println("Test " + caseNum + ": FAIL (Expected: " + expected + ", Got: " + result + ")");
    }
}
