package com.interview.notes.code.year.y2025.June.amazon.test3;

import java.util.*;
import java.util.stream.*;

public class KeyVulnerabilityMinimization {

    public static int findVulnerabilityFactor(List<Integer> key, int maxChange) {
        int n = key.size();
        int[] arr = key.stream().mapToInt(i -> i).toArray();

        // Binary search the answer
        int left = 1, right = n, answer = n;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (canReduceTo(arr, maxChange, mid)) {
                answer = mid;
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return answer;
    }

    // For fixed L, can we split all bad GCD>1 runs with at most maxChange changes?
    private static boolean canReduceTo(int[] arr, int maxChange, int L) {
        int n = arr.length;
        int totalChanges = 0;

        int start = 0;
        while (start < n) {
            if (arr[start] == 1) {
                start++;
                continue;
            }
            // Find the maximal segment [start, end] where all elements != 1
            int end = start;
            int segmentGcd = arr[start];
            while (end + 1 < n && arr[end + 1] != 1) {
                segmentGcd = gcd(segmentGcd, arr[end + 1]);
                if (segmentGcd == 1) break;
                end++;
            }
            // If GCD of segment is 1, move to next position
            if (gcdOfRange(arr, start, end) == 1) {
                start = end + 1;
                continue;
            }
            int segLen = end - start + 1;
            if (segLen >= L) {
                int splitsNeeded = (segLen + L - 1) / L; // ceil(segLen/L)
                totalChanges += splitsNeeded;
                if (totalChanges > maxChange) return false;
            }
            start = end + 1;
        }
        return true;
    }

    // Utility: GCD of [l, r] in arr
    private static int gcdOfRange(int[] arr, int l, int r) {
        int g = arr[l];
        for (int i = l + 1; i <= r; i++) {
            g = gcd(g, arr[i]);
            if (g == 1) return 1;
        }
        return g;
    }

    private static int gcd(int a, int b) {
        while (b != 0) {
            int tmp = a % b;
            a = b;
            b = tmp;
        }
        return a;
    }

    // Main method with test cases
    public static void main(String[] args) {
        List<TestCase> cases = Arrays.asList(
            new TestCase(Arrays.asList(2, 4, 9, 6), 1, 2),
            new TestCase(Arrays.asList(5, 10, 20, 10, 15, 5), 2, 2),
            new TestCase(Arrays.asList(4, 2, 4), 1, 1),
            new TestCase(IntStream.rangeClosed(1, 100_000).map(i -> 2).boxed().collect(Collectors.toList()), 0, 100_000),
            new TestCase(IntStream.rangeClosed(1, 100_000).map(i -> 1).boxed().collect(Collectors.toList()), 0, 1)
        );
        int i = 1;
        for (TestCase test : cases) {
            int result = findVulnerabilityFactor(test.key, test.maxChange);
            String status = (result == test.expected) ? "PASS" : "FAIL";
            System.out.printf("Test %d: Expected=%d, Actual=%d [%s]%n", i++, test.expected, result, status);
        }
    }

    static class TestCase {
        List<Integer> key;
        int maxChange;
        int expected;
        TestCase(List<Integer> key, int maxChange, int expected) {
            this.key = key;
            this.maxChange = maxChange;
            this.expected = expected;
        }
    }
}
