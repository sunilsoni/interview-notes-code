package com.interview.notes.code.year.y2025.June.amazon.test6;

import java.util.*;
import java.util.function.BiFunction;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class VulnerabilityFactor {

    // Public API
    public static int findVulnerabilityFactor(List<Integer> key, int maxChange) {
        int n = key.size();
        // Build a sparse table for RMQ-style gcd queries in O(n log n)
        int log = 32 - Integer.numberOfLeadingZeros(n);
        int[][] st = new int[log][n];
        for (int i = 0; i < n; i++) {
            st[0][i] = key.get(i);
        }
        for (int k = 1; k < log; k++) {
            int len = 1 << (k - 1);
            for (int i = 0; i + 2 * len <= n; i++) {
                st[k][i] = gcd(st[k - 1][i], st[k - 1][i + len]);
            }
        }
        // Helper to get gcd on [l..r] in O(1)
        BiFunction<Integer, Integer, Integer> rangeGcd = (l, r) -> {
            int length = r - l + 1;
            int k = 31 - Integer.numberOfLeadingZeros(length);
            return gcd(st[k][l], st[k][r - (1 << k) + 1]);
        };

        // Binary search minimal m
        int low = 0, high = n;
        while (low < high) {
            int mid = (low + high) / 2;
            if (canAchieve(mid, maxChange, n, rangeGcd))
                high = mid;
            else
                low = mid + 1;
        }
        return low;
    }

    // Check if vulnerability ≤ m is possible with ≤ maxChange edits
    private static boolean canAchieve(int m, int maxChange, int n,
                                      BiFunction<Integer, Integer, Integer> rangeGcd) {
        List<int[]> intervals = new ArrayList<>();
        // For each window [i..i+m], if gcd>1 we need to cover it
        for (int i = 0; i + m < n; i++) {
            if (rangeGcd.apply(i, i + m) > 1) {
                intervals.add(new int[]{i, i + m});
            }
        }
        // Greedy interval-cover: sort by end
        intervals.sort(Comparator.comparingInt(a -> a[1]));
        int used = 0, lastCovered = -1;
        for (int[] in : intervals) {
            if (in[0] > lastCovered) {
                // pick a change at position = in[1]
                used++;
                lastCovered = in[1];
                if (used > maxChange) return false;
            }
        }
        return true;
    }

    private static int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }

    // Simple main() for PASS/FAIL reporting, including a large test
    public static void main(String[] args) {
        class Test {
            final String name;
            final List<Integer> key;
            final int k, expected;

            Test(String name, List<Integer> key, int k, int expected) {
                this.name = name;
                this.key = key;
                this.k = k;
                this.expected = expected;
            }
        }
        List<Test> tests = Arrays.asList(
                new Test("Example1", Arrays.asList(4, 2, 4), 1, 1),
                new Test("Example2", Arrays.asList(5, 10, 20, 10, 15, 5), 2, 2),
                // edge: all primes, no change → vulnerability=1
                new Test("AllPrimes", Arrays.asList(2, 3, 5, 7, 11), 0, 1),
                // edge: single element
                new Test("Single", Collections.singletonList(17), 0, 1)
        );
        tests.stream().forEach(t -> {
            int out = findVulnerabilityFactor(t.key, t.k);
            String status = out == t.expected ? "PASS" : "FAIL";
            System.out.printf("%s: %s (got=%d, exp=%d)%n",
                    t.name, status, out, t.expected);
        });

        // Large input test: 100_000 elements all 2, k = n → expect 0
        int n = 100_000;
        List<Integer> large = IntStream.range(0, n).map(i -> 2).boxed().collect(Collectors.toList());
        int outLarge = findVulnerabilityFactor(large, n);
        System.out.printf("LargeTest: %s (got=%d, exp=0)%n",
                (outLarge == 0 ? "PASS" : "FAIL"), outLarge);
    }
}