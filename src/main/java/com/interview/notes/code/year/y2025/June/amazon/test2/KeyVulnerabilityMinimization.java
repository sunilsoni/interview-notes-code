package com.interview.notes.code.year.y2025.June.amazon.test2;

import java.util.*;
import java.util.stream.*;

public class KeyVulnerabilityMinimization {

    // Sparse Table for GCD Queries
    static class GCDSparseTable {
        int[][] table;
        int[] log2;

        public GCDSparseTable(int[] arr) {
            int n = arr.length;
            int k = 32 - Integer.numberOfLeadingZeros(n);
            table = new int[n][k];
            log2 = new int[n + 1];
            log2[1] = 0;
            for (int i = 2; i <= n; i++)
                log2[i] = log2[i >> 1] + 1;
            for (int i = 0; i < n; i++)
                table[i][0] = arr[i];
            for (int j = 1; j < k; j++) {
                for (int i = 0; i + (1 << j) <= n; i++) {
                    table[i][j] = gcd(table[i][j - 1], table[i + (1 << (j - 1))][j - 1]);
                }
            }
        }

        // Query GCD of interval [l, r]
        public int query(int l, int r) {
            int len = r - l + 1;
            int k = log2[len];
            return gcd(table[l][k], table[r - (1 << k) + 1][k]);
        }
    }

    public static int findVulnerabilityFactor(List<Integer> key, int maxChange) {
        int n = key.size();
        int[] arr = key.stream().mapToInt(i -> i).toArray();

        // Edge case: If maxChange >= n, can make all elements coprime (e.g., all 1)
        if (maxChange >= n) return 1;

        int left = 1, right = n, answer = n;
        GCDSparseTable st = new GCDSparseTable(arr);

        while (left <= right) {
            int mid = (left + right) / 2;
            if (canReduceTo(arr, st, maxChange, mid)) {
                answer = mid;
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return answer;
    }

    // For a given L, can we break all GCD>1 subarrays of length L with <=maxChange changes?
    private static boolean canReduceTo(int[] arr, GCDSparseTable st, int maxChange, int L) {
        int n = arr.length;
        List<Integer> windowsToCover = new ArrayList<>();
        for (int i = 0; i <= n - L; i++) {
            if (st.query(i, i + L - 1) > 1) {
                windowsToCover.add(i);
            }
        }
        // Greedy covering: select rightmost point for each window, skip windows already covered
        int coveredUntil = -1, changes = 0;
        for (int start : windowsToCover) {
            int end = start + L - 1;
            if (start > coveredUntil) {
                changes++;
                coveredUntil = end; // set the rightmost element in the window
                if (changes > maxChange) return false;
            }
        }
        return true;
    }

    private static int gcd(int a, int b) {
        while (b != 0) {
            int tmp = a % b;
            a = b;
            b = tmp;
        }
        return a;
    }

    // Main method for manual testing
    public static void main(String[] args) {
        List<TestCase> cases = Arrays.asList(
            new TestCase(Arrays.asList(2, 4, 9, 6), 1, 2),
            new TestCase(Arrays.asList(5, 10, 20, 10, 15, 5), 2, 2),
            new TestCase(Arrays.asList(4, 2, 4), 1, 1),
            new TestCase(IntStream.rangeClosed(1, 100_000).map(i -> 2).boxed().collect(Collectors.toList()), 0, 100_000),
            new TestCase(IntStream.rangeClosed(1, 100_000).map(i -> 1).boxed().collect(Collectors.toList()), 0, 1)
        );
        int i = 1;
        for (TestCase test : cases) {
            int result = findVulnerabilityFactor(test.key, test.maxChange);
            String status = (result == test.expected) ? "PASS" : "FAIL";
            System.out.printf("Test %d: Expected=%d, Actual=%d [%s]%n", i++, test.expected, result, status);
        }
    }

    static class TestCase {
        List<Integer> key;
        int maxChange;
        int expected;
        TestCase(List<Integer> key, int maxChange, int expected) {
            this.key = key;
            this.maxChange = maxChange;
            this.expected = expected;
        }
    }
}
